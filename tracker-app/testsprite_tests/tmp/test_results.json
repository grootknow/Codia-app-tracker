[
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "0b1c6b0d-ee1e-4275-85de-cd9b23baec55",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC001-Login and Landing on Master Map",
    "description": "Verify user can log in successfully and lands on the Master Map screen showing overall project progress and KPIs.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Enter valid user credentials and submit login.\n        frame = context.pages[-1]\n        # Click the Setup Wizard button to start login or setup process\n        elem = frame.locator('xpath=html/body/div/div/header/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in business information fields and proceed to next step.\n        frame = context.pages[-1]\n        # Input Business Name\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('RootKnow Inc.')\n        \n\n        frame = context.pages[-1]\n        # Input Domain Name\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rootknow.ai')\n        \n\n        frame = context.pages[-1]\n        # Input Primary Email\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('founder@rootknow.ai')\n        \n\n        frame = context.pages[-1]\n        # Click Next button to proceed to next step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Next button to proceed to the next step in the Setup Wizard.\n        frame = context.pages[-1]\n        # Click Next button to proceed from Infrastructure Setup to next step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the appropriate banking choice (Mercury) and click Next to proceed to the next step in the Setup Wizard.\n        frame = context.pages[-1]\n        # Select Mercury as the banking choice\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Next button to proceed to the next step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the recommended AI stack checkboxes (Claude 4.5, Grok 4 Fast, Gemini 2.0) and click Next to proceed to the next step.\n        frame = context.pages[-1]\n        # Select Claude 4.5 checkbox\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select Grok 4 Fast checkbox\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/label[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select Gemini 2.0 checkbox\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/label[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Next button to proceed to the next step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the missing Bank option to complete the configuration and proceed.\n        frame = context.pages[-1]\n        # Click the warning button to address missing Bank selection\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the missing Bank option to complete the setup and proceed to the Master Map dashboard.\n        frame = context.pages[-1]\n        # Click the Bank selection field to open options and select a bank\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful! Welcome to Master Map').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: User login was not successful or Master Map dashboard did not load as expected, indicating failure in login or navigation steps.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The user cannot complete the setup wizard due to a missing Bank selection that cannot be set. This prevents reaching the Master Map dashboard to verify project progress and KPIs. The issue has been reported and testing is stopped.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415563550218//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.212Z",
    "modified": "2025-11-06T07:52:43.688Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "1353d251-3c0b-4446-888a-df4619de78ae",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC002-Real-time Synchronization of Task Status Updates",
    "description": "Verify that task updates made by one user are reflected in real-time across all other active clients and visualizations.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Open Master Map view to prepare for task status update simulation.\n        frame = context.pages[-1]\n        # Click on the 'Master Map' button to open the Master Map view for task status update.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate user A updating a task status in the Checklist to IN_PROGRESS.\n        frame = context.pages[-1]\n        # Click on 'Phase 1: VPS Infrastructure' to open the checklist or task list for this phase to update a task status.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the status element of a task currently not IN_PROGRESS to update its status to IN_PROGRESS.\n        await page.mouse.wheel(0, 200)\n        \n\n        frame = context.pages[-1]\n        # Click on the status element of task '1.4 Order VPS4 (8GB) - Optional' which is currently PENDING to update status to IN_PROGRESS.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[7]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Phase 1: VPS Infrastructure' button to navigate back to that phase and update a task status to IN_PROGRESS for user A.\n        frame = context.pages[-1]\n        # Click on 'Phase 1: VPS Infrastructure' button to navigate to that phase checklist.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the status element of task '1.4 Order VPS4 (8GB) - Optional' which is currently PENDING to update status to IN_PROGRESS.\n        await page.mouse.wheel(0, 300)\n        \n\n        frame = context.pages[-1]\n        # Click on the status element of task '1.4 Order VPS4 (8GB) - Optional' to update status to IN_PROGRESS.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[14]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Task Status Updated Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Real-time task status update was not reflected across all active clients and visualizations as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test stopped due to a critical UI issue: clicking the task status element navigates away from the checklist instead of updating the status. Unable to verify real-time task update synchronization across clients.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415542353642//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.219Z",
    "modified": "2025-11-06T07:52:22.567Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "acadfef1-127f-4d2c-86ef-40eda2e19a42",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC003-Task Dependency Enforcement on Status Updates",
    "description": "Verify that task dependencies and blockers prevent invalid status updates and enforce correct workflow.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 'âœ¨ Setup Wizard' button to start the workflow and access tasks.\n        frame = context.pages[-1]\n        # Click on the 'âœ¨ Setup Wizard' button to start the workflow and access tasks.\n        elem = frame.locator('xpath=html/body/div/div/header/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to the task list or workflow page where task statuses can be updated to test dependencies and blockers.\n        frame = context.pages[-1]\n        # Click the 'Next' button to proceed to the next step or task list where task statuses can be updated.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Look for a navigation element or menu that leads to the task list or workflow page where task statuses can be updated.\n        frame = context.pages[-1]\n        # Click the 'ðŸ†' button or element that might lead to the task list or milestones overview.\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'ðŸ†' button (index 0) on the main page to see if it leads to the task list or milestones overview.\n        frame = context.pages[-1]\n        # Click the 'ðŸ†' button to try to access the task list or milestones overview.\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Look for clickable elements related to tasks or status updates in the milestones overview or try to open task details to update status.\n        frame = context.pages[-1]\n        # Click the 'ðŸ†' button to ensure focus on milestones overview.\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Business' tab (index 1) to check if task status update controls are available there.\n        frame = context.pages[-1]\n        # Click the 'Business' tab to check for task status update controls.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[3]/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'Business' tab button (index 1) again to attempt tab switch or try other tabs to find task status update controls.\n        frame = context.pages[-1]\n        # Click the 'Business' tab button to attempt switching tabs for task status update controls.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[3]/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Back' button (index 5) to try to navigate back to the previous step where task status update controls might be available or to find navigation to the task list.\n        frame = context.pages[-1]\n        # Click the 'Back' button to navigate to the previous step in the Setup Wizard.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'ðŸ†' button (index 0) to focus on the milestones overview and check for any interactive elements related to task status updates or task details.\n        frame = context.pages[-1]\n        # Click the 'ðŸ†' button to focus on the milestones overview.\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Next' button (index 8) to proceed to the next step in the Setup Wizard and check if task status update controls appear.\n        frame = context.pages[-1]\n        # Click the 'Next' button to proceed to the next step in the Setup Wizard.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Next' button (index 6) to proceed to the next step in the Setup Wizard and check if task status update controls appear.\n        frame = context.pages[-1]\n        # Click the 'Next' button to proceed to the next step in the Setup Wizard.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Task Status Update Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The system did not prevent marking a task as DONE while its dependent task is still PENDING or BLOCKED, violating task dependency enforcement.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify that task dependencies and blockers prevent invalid status updates and enforce correct workflow could not be fully completed. Although the milestones overview and task dependencies were identified, the frontend UI does not provide controls to update task statuses or test dependency enforcement. Therefore, it was not possible to attempt marking a task as DONE while its dependent task was still PENDING or BLOCKED, nor to verify system warnings or successful status updates respecting dependencies. The test is incomplete due to these UI limitations.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415693855244//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.227Z",
    "modified": "2025-11-06T07:54:54.019Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "0e504cae-fabb-44aa-80d1-b64b6ebca0a0",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC004-Setup Wizard Full Configuration Workflow",
    "description": "Verify that the 5-step Setup Wizard correctly loads milestones, allows full configuration input, and saves data to localStorage.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Setup Wizard' button to launch the Setup Wizard.\n        frame = context.pages[-1]\n        # Click the 'Setup Wizard' button to launch the Setup Wizard.\n        elem = frame.locator('xpath=html/body/div/div/header/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enter valid data into the Business Name, Domain Name, and Primary Email fields, then click Next to proceed to Infrastructure step.\n        frame = context.pages[-1]\n        # Enter Business Name\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('RootKnow Inc.')\n        \n\n        frame = context.pages[-1]\n        # Enter Domain Name\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('rootknow.ai')\n        \n\n        frame = context.pages[-1]\n        # Enter Primary Email\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('founder@rootknow.ai')\n        \n\n        frame = context.pages[-1]\n        # Click Next to proceed to Infrastructure step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select VPS Provider, Number of VPS, and Region as per recommended setup, then click Next to proceed to Financial step.\n        frame = context.pages[-1]\n        # Select VPS Provider 'Contabo (Recommended - Best price/performance)'\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[3]/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select Number of VPS '4 VPS (+Code Execution)'\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[4]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select Region 'Singapore (Recommended for Asia)'\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[5]/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Next to proceed to Financial step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the 'Mercury' banking option and click Next to proceed to the AI Models step.\n        frame = context.pages[-1]\n        # Select Mercury banking option\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Next to proceed to AI Models step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select all three AI models (Claude 4.5 Sonnet, Grok 4 Fast, Gemini 2.0 Flash) and click Next to proceed to the Review step.\n        frame = context.pages[-1]\n        # Select Claude 4.5 Sonnet AI model checkbox\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select Grok 4 Fast AI model checkbox\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/label[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select Gemini 2.0 Flash AI model checkbox\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/label[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Next to proceed to Review step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Go back to the Financial step, select a bank option, then return to Review step to complete the wizard.\n        frame = context.pages[-1]\n        # Click Back button to return to Financial step\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Setup Wizard Completed Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The 5-step Setup Wizard did not complete successfully. Milestones may not have loaded, configuration input may be incomplete, or data was not saved to localStorage as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Setup Wizard test stopped due to critical issue: missing bank selection cannot be corrected on Review step, blocking completion and saving. The wizard does not allow navigation back to Financial step or bank selection, causing validation failure. Further testing halted until this is fixed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415563542035//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.232Z",
    "modified": "2025-11-06T07:52:43.674Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "e6d3f118-9511-415e-9e77-aae32db55d19",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC005-Founder Guide Section Accessibility and Navigation",
    "description": "Verify that the Founder Guide loads correctly and all 6 sections can be expanded and collapsed with content displayed properly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Founder Guide' button to navigate to the Founder Guide section.\n        frame = context.pages[-1]\n        # Click the 'Founder Guide' button to navigate to the Founder Guide section.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[14]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Expand the 'Accounts' section (index 17) to verify it expands and shows detailed instructions.\n        frame = context.pages[-1]\n        # Expand the 'Accounts' section to verify it expands and shows detailed instructions.\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Expand the 'Domain & DNS' section (index 18) to verify it expands and shows detailed instructions.\n        frame = context.pages[-1]\n        # Collapse the 'Accounts' section to verify it collapses and hides content properly.\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Founder Guide Complete Success').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The Founder Guide did not load correctly or the sections did not expand/collapse as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing of the Founder Guide section toggling functionality is incomplete due to a UI issue. The 'Accounts' section expands but cannot be collapsed, and other sections do not expand. Recommend developer investigation to fix the toggle behavior. Task stopped.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415429567181//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.238Z",
    "modified": "2025-11-06T07:50:29.693Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "40f94501-ef79-4dc3-9cc7-9c92979a7f9f",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC006-Visual Gantt Chart Interaction and Data Accuracy",
    "description": "Verify the Visual Gantt Chart renders tasks accurately with correct coloring, tooltips, and allows zoom and detail modal interactions.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the Visual Gantt Chart button to navigate to the Visual Gantt Chart view.\n        frame = context.pages[-1]\n        # Click the Visual Gantt Chart button to navigate to the Visual Gantt Chart view\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[10]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Hover over a task bar to verify tooltip displays detailed task information.\n        frame = context.pages[-1]\n        # Hover over the first task bar to trigger tooltip display\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div[3]/div/div[2]/div[2]/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Use zoom controls to adjust zoom from 50% to 200% and verify smooth zoom and timeline adjustment.\n        frame = context.pages[-1]\n        # Click zoom out button to reduce zoom from 100% to 50%\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the Visual Gantt Chart button to navigate to the Visual Gantt Chart view.\n        frame = context.pages[-1]\n        # Click the Visual Gantt Chart button to navigate to the Visual Gantt Chart view\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[10]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Zoom Out button to reduce zoom to 50% and verify timeline adjusts accordingly.\n        frame = context.pages[-1]\n        # Click Zoom Out button to reduce zoom from 100% to 50%\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Zoom In button to increase zoom from 75% to 100% and verify timeline adjusts accordingly.\n        frame = context.pages[-1]\n        # Click Zoom In button to increase zoom from 75% to 100%\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click a task bar to verify detail modal opens with full task details.\n        frame = context.pages[-1]\n        # Click a task bar to open detail modal with full task details\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div[3]/div/div[2]/div[2]/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Continue verifying additional tasks for correct color coding and tooltip display by hovering over other task bars.\n        frame = context.pages[-1]\n        # Hover over another task bar to verify tooltip displays detailed task information\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Hover over additional task bars to verify tooltips display detailed task information for multiple tasks.\n        frame = context.pages[-1]\n        # Hover over another task bar to verify tooltip display\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div[4]/div/div[2]/div[2]/div[12]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Hover over additional task bars to verify tooltip display for more tasks.\n        frame = context.pages[-1]\n        # Hover over another task bar to verify tooltip display\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[14]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Visual Gantt').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Complete Phase 0: Prerequisites').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ðŸ“ˆ Visual Gantt').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Track your progress in Phase 0: Prerequisites tab above. Mark tasks as \"In Progress\" â†’ \"Done\" as you complete them!').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415554586412//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.244Z",
    "modified": "2025-11-06T07:52:34.778Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "f869ad79-5537-40e9-af72-f3e6a100642b",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC007-Kanban Board Drag-and-Drop Task Status Updates",
    "description": "Verify that tasks can be dragged and dropped between Pending, In Progress, Done, and Blocked columns and updates persist.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the Kanban button to navigate to the Kanban Board.\n        frame = context.pages[-1]\n        # Click the Kanban button to navigate to the Kanban Board.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[11]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Task Successfully Moved to Completed')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Tasks could not be dragged and dropped between Pending, In Progress, Done, and Blocked columns or the updates did not persist as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The Kanban Board shows tasks correctly in Pending, In Progress, and Done columns. The Blocked column is not visible, so full drag-and-drop testing including Blocked status and blocker tracking could not be completed. Drag-and-drop functionality between visible columns appears supported by the UI layout, but actual drag-and-drop and persistence after reload were not tested. Task is partially verified but not fully complete due to these limitations.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415494642075//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.251Z",
    "modified": "2025-11-06T07:51:34.826Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "8e58042b-a0e7-455a-8f8b-4d22e88fb0f4",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC008-Activity Logs Real-time Feed and Accuracy",
    "description": "Verify activity logs correctly display system and task events with accurate timestamps and update live without refresh.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the Logs button to navigate to Activity Logs view.\n        frame = context.pages[-1]\n        # Click on the Logs button to navigate to Activity Logs view.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[13]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to a client or task update section to perform a task update on another client.\n        frame = context.pages[-1]\n        # Click on Phase 0: Prerequisites to navigate to a client or task update section for performing a task update.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the Logs button to return to Activity Logs view and then find a way to perform a task update on another client.\n        frame = context.pages[-1]\n        # Click on the Logs button to navigate to Activity Logs view.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[13]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Phase 0: Prerequisites' to navigate to a client or task update section to perform a task update.\n        frame = context.pages[-1]\n        # Click on Phase 0: Prerequisites to navigate to a client or task update section for performing a task update.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the Logs button to navigate back to the Activity Logs view and verify the log feed updates live with the new event.\n        frame = context.pages[-1]\n        # Click on the Logs button to navigate back to the Activity Logs view.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[13]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=PHASE_0_AI_GENERATED').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Created Phase 0 with 24 AI-generated tasks from V10 diagram analysis').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=11/5/2025, 5:58:57 PM').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=SUCCESS').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=PHASE_0_CREATED').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Added Phase 0: Prerequisites with 31 tasks covering accounts, domains, API keys, third-party services, security, and local dev setup').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=11/5/2025, 5:44:36 PM').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=PROJECT_INITIALIZED').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=V10 ULTIMATE tracker initialized with 98 tasks (20 groups, 78 tasks) across 4 phases with parent-child hierarchy').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=11/5/2025, 5:20:57 PM').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=CODIA Platform Tracker â€¢ Real-time â€¢ Powered by Supabase').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415497550899//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.258Z",
    "modified": "2025-11-06T07:51:37.675Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "826f3e40-1001-48e7-8517-d0cbd9bb8e38",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC009-Master Map Visualization and Data Consistency",
    "description": "Verify Master Map graph visualizes tasks with accurate dependencies and relationships reflecting current project state.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Master Map' button to navigate to the Master Map screen.\n        frame = context.pages[-1]\n        # Click the 'Master Map' button to navigate to the Master Map screen.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to locate the Master Map graph visualization and verify task nodes and dependency edges.\n        await page.mouse.wheel(0, 600)\n        \n\n        # -> Click on a task or phase button to attempt updating a task dependency status or blocker.\n        frame = context.pages[-1]\n        # Click the 'Phase 1: VPS Infrastructure' button to open task details for updating dependency status.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to find an interactive element to update a task dependency or blocker status.\n        await page.mouse.wheel(0, 400)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Master Map').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Phase 1: VPS Infrastructure').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Phase 2: Databases').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Phase 3: AI Brain').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Phase 4: Operations').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Phase 5: Media & Content').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=1. VPS Provisioning').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Order VPS1 (24GB)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Order VPS2 (24GB)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Order VPS3 (12GB)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Order VPS4 (8GB) - Optional').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415488554751//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.264Z",
    "modified": "2025-11-06T07:51:28.666Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "8889202d-5dc4-42f8-b32c-6ba37cbd2bda",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC010-Mermaid Diagram Viewer Rendering and Toggle Functionality",
    "description": "Verify Mermaid Diagram Viewer fetches database-stored diagrams correctly and toggles between visual and code views.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'ðŸ“ V10 Diagrams' button to open Mermaid Diagram Viewer and load an .mmd document from the database.\n        frame = context.pages[-1]\n        # Click on 'ðŸ“ V10 Diagrams' button to open Mermaid Diagram Viewer\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[15]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on a diagram button that is loaded in the database to open and render the Mermaid diagram.\n        frame = context.pages[-1]\n        # Click on '00-V10-MASTER-DATA-MAP' diagram button to load Mermaid diagram from database\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Code View' button to toggle from Visual view to Code view and verify Mermaid source code is displayed.\n        frame = context.pages[-1]\n        # Click 'Code View' button to toggle to Mermaid source code view\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Visual Diagram' button to toggle back from Code View to Visual Diagram view and verify the interactive SVG diagram re-displays correctly.\n        frame = context.pages[-1]\n        # Click 'Visual Diagram' button to toggle back to Visual Diagram view\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=00-V10-MASTER-DATA-MAP').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Code View').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Visual Diagram').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415436383094//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.270Z",
    "modified": "2025-11-06T07:50:36.567Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "57ac9a6e-5d9a-45b8-8f3c-b591cb47d790",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC011-GAP Analysis Dashboard Data Accuracy and Refresh",
    "description": "Verify GAP Analysis Dashboard accurately shows real-time project metrics according to backend data and refreshes automatically.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the GAP Analysis button to open the GAP Analysis Dashboard.\n        frame = context.pages[-1]\n        # Click on the GAP Analysis button to open the GAP Analysis Dashboard.\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate or trigger task status updates from another client to test real-time dashboard update.\n        frame = context.pages[-1]\n        # Click Setup Wizard to simulate task status updates from another client or trigger updates.\n        elem = frame.locator('xpath=html/body/div/div/header/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Close the Setup Wizard modal to return to GAP Analysis Dashboard and verify if dashboard metrics update automatically.\n        frame = context.pages[-1]\n        # Click the close button (index 0) on the Setup Wizard modal to close it and return to GAP Analysis Dashboard.\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dashboard metrics are perfectly synchronized with backend data').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: GAP Analysis Dashboard did not accurately show real-time project metrics or failed to refresh automatically as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to close the Setup Wizard modal, which blocks further verification of the GAP Analysis Dashboard's real-time update and auto-refresh features.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415409805986//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.285Z",
    "modified": "2025-11-06T07:50:09.938Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "239d538d-d129-44f1-a9d1-914004809ed7",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC012-Timeline View Chronological Task Ordering and Milestone Display",
    "description": "Verify Timeline View shows tasks in correct chronological order with milestones highlighted and status indicators visible.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Open Timeline View by clicking the Timeline button\n        frame = context.pages[-1]\n        # Click the Timeline button to open Timeline View\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[12]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Update a task's status and verify the timeline reflects the changes\n        frame = context.pages[-1]\n        # Click Kanban button to navigate to Kanban view to update a task's status\n        elem = frame.locator('xpath=html/body/div/div/nav/div[2]/div/button[11]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Update a task's status from Pending to In Progress by clicking and changing status\n        frame = context.pages[-1]\n        # Click on a Pending task card to open details for status update\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=All tasks are perfectly ordered and milestones are highlighted')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Timeline View does not show tasks in correct chronological order with milestones highlighted and status indicators visible as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to update task status on Kanban board. Task status update UI does not appear after clicking task card, preventing verification of Timeline View reflecting status changes and milestone highlighting. Issue reported for investigation.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415467780438//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.303Z",
    "modified": "2025-11-06T07:51:07.932Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "ae58c647-9b94-4714-bdaf-d7985b17ae9d",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC013-Supabase Backend API Endpoint Validation",
    "description": "Verify all Supabase backend API endpoints respond correctly with expected data and handle errors suitably.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Send GET requests to all endpoints like /tasks, /gap_analysis, /logs, /tracker_app_data, /phases and confirm valid 200 responses.\n        await page.goto('http://localhost:3000/api/tasks', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to /api/gap_analysis endpoint to verify GET 200 response.\n        await page.goto('http://localhost:3000/api/gap_analysis', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to /api/logs endpoint to verify GET 200 response.\n        await page.goto('http://localhost:3000/api/logs', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to /api/tracker_app_data endpoint to verify GET 200 response.\n        await page.goto('http://localhost:3000/api/tracker_app_data', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to /api/phases endpoint to verify GET 200 response.\n        await page.goto('http://localhost:3000/api/phases', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Start validating data schemas for all GET responses to ensure data completeness and correctness.\n        await page.goto('http://localhost:3000/api/tasks', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Extract and validate data schema for /api/gap_analysis GET response.\n        await page.goto('http://localhost:3000/api/gap_analysis', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Extract and validate data schema for /api/logs GET response.\n        await page.goto('http://localhost:3000/api/logs', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Extract and validate data schema for /api/tracker_app_data GET response.\n        await page.goto('http://localhost:3000/api/tracker_app_data', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Extract and validate data schema for /api/phases GET response.\n        await page.goto('http://localhost:3000/api/phases', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Supabase API Endpoint Validation Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan execution failed: Supabase backend API endpoints did not respond correctly or data validation failed as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of Supabase backend API endpoint verification:\n\n1. GET Endpoints (/tasks, /gap_analysis, /logs, /tracker_app_data, /phases):\n- All endpoints responded with valid 200 status.\n- Data schema validation completed for /tasks, /gap_analysis, /logs, and /tracker_app_data with expected fields and data completeness confirmed.\n- /api/phases endpoint page loaded but data schema extraction and validation is pending.\n\n2. PUT Requests for Task Updates:\n- Not tested yet. Valid and invalid payloads need to be sent to verify successful updates and error handling.\n\n3. WebSocket Subscription:\n- Not tested yet. Subscription to real-time task update notifications needs to be verified.\n\nConclusion: The GET endpoints are verified for correct responses and data schema integrity except for /api/phases which is pending. PUT request and WebSocket subscription tests remain to be done for full verification.\n\nTask is not fully finished as per user request.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415531220632//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.311Z",
    "modified": "2025-11-06T07:52:11.338Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "8d101468-550b-45a1-aa40-c8ca20b7c578",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC014-Edge Case: Large Number of Tasks and Deep Hierarchies",
    "description": "Verify that the application handles large task volumes and deep hierarchical task structures without UI or performance degradation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 'âœ¨ Setup Wizard' button to start the setup and import or generate a large dataset with >1000 tasks and multiple nested levels.\n        frame = context.pages[-1]\n        # Click on the 'âœ¨ Setup Wizard' button to start the setup process.\n        elem = frame.locator('xpath=html/body/div/div/header/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the Business Name, Domain Name, and Primary Email fields with sample data and click 'Next' to proceed to the next step.\n        frame = context.pages[-1]\n        # Input Business Name\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Business Inc.')\n        \n\n        frame = context.pages[-1]\n        # Input Domain Name\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testbusiness.ai')\n        \n\n        frame = context.pages[-1]\n        # Input Primary Email\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('contact@testbusiness.ai')\n        \n\n        frame = context.pages[-1]\n        # Click 'Next' button to proceed to the next step in Setup Wizard\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Next' button to proceed to the next step in the Setup Wizard.\n        frame = context.pages[-1]\n        # Click 'Next' button to proceed to the next step in Setup Wizard\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select 'No' for US entity (Delaware C-Corp) and choose 'Wise' as the banking option, then click 'Next' to proceed to the next step.\n        frame = context.pages[-1]\n        # Select 'No' for US entity (Delaware C-Corp)\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select 'Wise' as the banking option\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[3]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click 'Next' button to proceed to the next step in Setup Wizard\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the recommended AI stack models (Claude 4.5, Grok 4 Fast, Gemini 2.0) by checking their checkboxes, then click 'Next' to proceed to the next step.\n        frame = context.pages[-1]\n        # Select Claude 4.5 Sonnet checkbox\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select Grok 4 Fast checkbox\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/label[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select Gemini 2.0 Flash checkbox\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/label[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click 'Next' button to proceed to the next step in Setup Wizard\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'ðŸš€ Generate My V10 Roadmap' button to generate the large dataset of tasks and load the roadmap view.\n        frame = context.pages[-1]\n        # Click 'ðŸš€ Generate My V10 Roadmap' button to generate the large dataset of tasks and load the roadmap view\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=All tasks loaded successfully with no performance issues').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The application did not handle large task volumes and deep hierarchical task structures without UI or performance degradation as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to failure in generating the roadmap. The 'Generate My V10 Roadmap' button does not respond or navigate as expected, preventing further testing of large task volumes and deep hierarchical task structures. Issue reported for developer investigation.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415535862584//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.359Z",
    "modified": "2025-11-06T07:52:15.988Z"
  },
  {
    "projectId": "fe66b540-23be-42ee-b730-e708eb6ed2ee",
    "testId": "d503ccb9-28ac-45ac-b123-236522757243",
    "userId": "5428b428-3021-70cb-432d-6002d89bed43",
    "title": "TC015-Error Handling on Network Failure During Updates",
    "description": "Verify that the system gracefully handles network interruptions or backend errors during task update operations.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Setup Wizard' to start a task update operation for testing.\n        frame = context.pages[-1]\n        # Click on Setup Wizard button to start task update operation.\n        elem = frame.locator('xpath=html/body/div/div/header/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate network failure or force API error during task status update PUT request by modifying business name and clicking Next to trigger update.\n        frame = context.pages[-1]\n        # Input business name to trigger task update operation.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Business Name Network Failure')\n        \n\n        frame = context.pages[-1]\n        # Click Next button to trigger task update and simulate network failure or API error.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate network failure or force API error during task status update PUT request by clicking Next button to trigger update with network failure.\n        frame = context.pages[-1]\n        # Click Next button to trigger task update and simulate network failure or API error.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate network failure or force API error during task status update PUT request by clicking the 'Next' button to trigger update with network failure.\n        frame = context.pages[-1]\n        # Click Next button to trigger task update and simulate network failure or API error.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate network failure or force API error during task status update PUT request by clicking the 'Next' button to trigger update with network failure.\n        frame = context.pages[-1]\n        # Click Next button to trigger task update and simulate network failure or API error.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate network failure or force API error during task status update PUT request by clicking the 'Complete all fields first' button or relevant update trigger to test error handling.\n        frame = context.pages[-1]\n        # Click 'Complete all fields first' button to simulate task update and trigger network failure or API error.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate network failure or force API error during task update PUT request by filling in missing required fields and clicking Next to trigger update with network failure.\n        frame = context.pages[-1]\n        # Click Business step to fill missing required fields to enable update.\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in missing required fields (Domain, Email, Bank selection, AI models) to enable task update operation and simulate network failure during update.\n        frame = context.pages[-1]\n        # Click 'Complete all fields first' button to trigger filling missing fields.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in missing required fields (Domain, Email, Bank selection, AI models) to enable task update operation and simulate network failure during update.\n        frame = context.pages[-1]\n        # Click 'Complete all fields first' button to trigger filling missing fields.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to the 'Business' step to start filling missing required fields to enable task update operation.\n        frame = context.pages[-1]\n        # Click 'Business' step to fill missing required fields.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Network connection is stable and all updates succeeded').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The system did not gracefully handle network interruptions or backend errors during task update operations as expected. User did not receive proper error feedback or the update was lost.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The system is stuck on the 'Review & Confirm' step due to missing required fields and UI validation blocking progression. Navigation to previous steps to fill missing fields is not possible, preventing further testing of network failure handling during task updates. Reported the issue and stopped further testing.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/5428b428-3021-70cb-432d-6002d89bed43/1762415579164321//tmp/test_task/result.webm",
    "created": "2025-11-06T07:47:33.366Z",
    "modified": "2025-11-06T07:52:59.289Z"
  }
]
